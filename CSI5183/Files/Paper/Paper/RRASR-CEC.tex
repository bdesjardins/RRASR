\documentclass[conference]{IEEEtran}

\usepackage{array}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{algorithm, algpseudocode}
\usepackage{subfigure}
\usepackage{url}
\usepackage{verbatim}
\usepackage{color}
\usepackage{placeins}
\usepackage{multirow}

% correct bad hyphenation here

% new commands
\algnewcommand\AlgInput{\item[\textbf{Input:}]}
\algnewcommand\AlgOutput{\item[\textbf{Output:}]}
\DeclareMathOperator*{\argmax}{argmax}
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}

% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%

\IEEEoverridecommandlockouts

\newcommand{\MYfooter}{\smash{
\hfil\parbox[t][\height][t]{\textwidth}{\centering
\thepage}\hfil\hbox{}}}

\makeatletter

% title page
\def\ps@IEEEtitlepagestyle{%
\def\@oddhead{\parbox[t][\height][t]{\textwidth}{\centering
Manuscript submitted to IEEE CEC 2015 (oral presentation preferred)\\
\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}
}\hfil\hbox{}}%
\def\@evenhead{\scriptsize\thepage \hfil \leftmark\mbox{}}%
%\def\@oddfoot{ 978-1-4799-6230-3/14/\$31.00~\textcopyright~2014 IEEE\hfil 
%\leftmark\mbox{}}%
\def\@evenfoot{\MYfooter}}

\makeatother
% make changes take effect
\pagestyle{headings}
% adjust as needed
\addtolength{\footskip}{0\baselineskip}
\addtolength{\textheight}{-1\baselineskip}  

\begin{document}
\title{A Multi-Objective Optimization Approach to Reliable Robot-Assisted Sensor Relocation}

\author{Benjamin Desjardins, Rafael Falcon, Rami Abielmona and Emil Petriu
\thanks{B. Desjardins and E. Petriu are with the School of Electrical Engineering \& Computer Science,
        University of Ottawa, Ottawa ON, K1N 6N5 Canada
        {\tt\small \{bdesj038, petriu\}@uottawa.ca}}%
\thanks{R. Falcon and R. Abielmona are with the Research \& Engineering Division,
        Larus Technologies Corporation, Ottawa ON, K1P 5V5 Canada
        {\tt\small \{rafael.falcon,rami.abielmona\}@larus.com}}%				
			  }%

\vspace{-1cm}
% make the title area
\maketitle

\begin{abstract}
Robot-Assisted Sensor Relocation solutions traditionally focus only on one aspect of the problem, minimizing the tour length of the robot. In reality there are many objectives to consider. With this in mind we propose a Multi-Objective Optimization approach to the problem where we consider two more objectives in addition to the tour length. These objectives result from the fact that a given sensor selected to replace a dead sensor in the region may not be in perfect condition and that another sensor may be a better option. With this in mind we apply Evolutionary Multi-Objective Optimization algorithms in order to find feasible solutions to the expanded problem.
\end{abstract}

\vspace{0.25cm}

\noindent \begin{IEEEkeywords}
evolutionary multi-objective optimization; genetic algorithms; wireless sensor and robot networks; robotics; wireless sensor networks; sensor relocation
\end{IEEEkeywords}

\IEEEpeerreviewmaketitle

\section{Introduction}
\label{sec:Intro}

Wireless Sensor Networks (WSNs) consist of a group of wireless sensors in a region of interest (ROI). A wireless sensor is defined as a device equipped with some wireless communication device, one or more pieces of monitoring hardware, and a battery. These sensors are deployed to gather low-level information in a ROI for high-level applications in domains such as medicine, defense, and infrastructure. As such, these sensors must be deployed in such a way that there are no internal sensing holes.

Wireless Sensor and Robot Networks (WSRNs) are an extension of WSNs wherein a robot, or group of robots, perform some sensing and/ or actuation task related to the WSN. In these cases, while the sensors may be limited in their capabilities, the robots are flexible, generally mobile and are designed to assist, maintain, and/or optimize the sensor network. 

Robot-Assisted Sensor Relocation (RASR) is a specific WSRN problem. In this instance, the robot(s) are responsible for relocating sensors in the network. This falls into two different categories: deployment, and post-deployment. In the deployment case, the robot(s) are responsible for arranging sensors in a ROI such that coverage is maximized. There are again two variations of this. In the first, the robot holds all of the sensors and places them where necessary. In the second case, sensors are randomly distributed in the ROI and the robot must relocate them. For post-deployment RASR the robot(s) will reconfigure sensors when there is a change in the network. In most cases this refers to a currently active sensor being damaged or its battery running out. The solution here is for the robot to replace the dead sensor with another, be it from storage or an extra already in the ROI.

We propose an approach to the post-deployment case in which extra sensors are randomly distributed in the ROI. Our approach applies Evolutionary Multi-Objective Optimization (EMOO) algorithms  to the problem. Traditionally, the only objective of the problem is finding the minimal tour for the robot to take; in reality there are many factors to consider. Our approach considers three objectives: the length of the robot's tour, the lifetime of the resulting sensor network, and a metric we propose called the tour robustness. The final two objectives are based on the fact that passive sensors in the ROI are not necessarily at full battery capacity and therefore the choice of passive sensor makes a difference in the resulting sensor network.

In this paper we make the following contributions: we provide a more realistic approach to the solving of the RASR problem by taking into account more problem objectives and we introduce two new metrics, path robustness and path lifetime, in order to determine how well the sensors have been placed.

The rest of the manuscript is structured as follows. Section \ref{sec:RelatedWork} briefly reviews relevant works. Section \ref{sec:MOOProblem} formalizes the RRASR problem while Section \ref{sec:Algorithms} elaborates on the algorithmic building blocks for the EMOO schemes under consideration. Section \ref{sec:Experiments} is concerned with the empirical evaluation of the methodology being put forth. Finally, Section \ref{sec:Conclusions} concludes the paper.

\section{Related Work}
\label{sec:RelatedWork}

This Section briefly reviews relevant studies concerning robot-assisted sensor relocation and 
its underlying optimization backbone.

\subsection{Robot-Assisted Sensor Relocation}
\label{sec:RelatedWork:RASR}

The existing studies on RASR can be placed into different categories. Some of them, such as \cite{fletcher2010back} and \cite{li2014placing}, focus on the deployment of a sensor network in a ROI while compensating for issues that occur during said deployment. Others, like our approach, are focused on repairing a network that is damaged post deployment. Many of these, such as \cite{wanglocalized}, \cite{caliskanelli2014using}, \cite{lian2012novel}, use Ant Colony Optimization (ACO) approaches to this problem. One study, \cite{li22market}, uses a market-based approach as its sensor relocation strategy. Another study, \cite{magklara2013node}, offers two continuous algorithms, a reactive and a proactive, which can be used to maintain a WSRN. A study by Miao and Yu-Ping \cite{miao2014coverage} uses an approach similar to ours in which a Traveling Salesman Problem (TSP)-based solution is offered. It uses a genetic algorithm in order to find the best available solution and guarantees the correctness of its population by using a dual-objective approach. The primary objective is to maximize number of sensing holes visited and the secondary is to minimize the tour length. This differs from our solution in that the secondary objective in \cite{miao2014coverage} is only considered in situations where the primary objective is either maximized or two solutions have equivalent fitness in the primary objective.

\subsection{Related Optimization Problems}
\label{sec:RelatedWork:Optimization}

A more general form of the RASR problem has been studied in terms of an optimization problem. This problem has been explored under different names including: selective pickup and delivery problem and the delivery and selective pickup problem. They both refer to a version of the vehicle routing problem in which all delivery locations must be satisfied, but not all pickup locations must be visited. As TSP is a general version of this problem, this problem is also NP-hard. 

There have been studies conducted using genetic algorithms try and find optimal solutions to a given problem instance. Liao and Ting take a standard genetic algorithm approach to this problem in \cite{liao2010evolutionary}. Notably they use a repair function in order to deal with infeasible solutions. They expand on their approach in \cite{ting2013selective} by using a memetic algorithm in order to improve their solutions. It is worth mentioning that improvements to the local search will improve the entire algorithm. Liao and Ting also look to adaptive mutation to improve solutions from both a standard genetic algorithm approach and a memetic algorithm approach in \cite{liao2012evolutionary}. A study by Bruck et al uses a genetic algorithm with variable neighbourhood search in order to find a solution to the problem \cite{bruck2012hybrid}. This is expanded in \cite{6421345} where solutions for the multiple vehicle version of the problem are sought. Huang and Ting also proposed solution to the multiple vehicle version of the problem in \cite{5949836}. Bruck and dos Santos expand again on \cite{bruck2012hybrid} in \cite{bruck2012evolutionary} where they use a different gene representation for their genetic algorithm as well as using data mining techniques in order to improve their crossover and mutation operators.

\textbf{Is it worth mentioning the branch and price paper?} \\



\section{RRASR: A Multi-Objective RASR Formulation}
\label{sec:MOOProblem}

Our problem can be formulated as a combinatorial optimization problem. We represent our sensor network as a complete undirected graph $G=(V, E)$ with vertex set $V=\{v_0,...,v_n \}$ and edge set $E=\{(v_i,v_j) | v_i,v_j \in  V, v_i \neq v_j\}$ in which each edge $(v_i,v_j)$ has a cost $d_{ij}>0$ representing the euclidean distance between $v_i$ and $v_i$.

Each vertex represents a passive sensor or a sensing hole and has an associated unitary demand $q_i(1 \text{ for passive sensors and } {-1} \text{ for sensing holes})$. The base station is denoted as $v_0$ with $q_0=0$. Therefore we can say that each non-depot vertex either belongs to the set of passive sensors $S=\{v_i\},v_i \in V, q_i=1$ or the set of sensing holes $H=\{v_i\},v_i \in V, q_i=0$. This implies that $V = \{ S \cup H \cup v_0\}$.

Each sensor has an associated battery level denoted by 

\[ p_i = \left\{ \begin{array}{ll}
0 & \quad \text{if $v_i \in H$} \\
{-1} & \quad \text{if $i = 0$} \\
0 < p_i < 100 & \quad \text{if $v_i \in S$} \\
\end{array} \right. \]

There is a unique commodity (sensors) to be transported by the robot from one place to another. The robot can carry at most $Q_{max}$ sensors and leaves the base station with an initial cargo $Q_0$, $0 \leq Q_0 \leq Q_{max}$. A robot will always drop its most recently picked up sensor when it reaches a sensor hole.

We also consider the set of all active nodes $A=\{a_0,...,a_m,v_0\}$ that form the sensing network in the ROI. We then need to consider the edge set $E'=\{(v_i,a_j)|v_i \in  H, a_j \in A\}$.

All vertices $v_i \in V, 0<i<n$ have a communication radius of $R$. Each sensing hole has an active degree $g_i$ such that $g_i = |\{d'_{ij}) \leq R\}|$ and $d'_{ij}$ stands for the Euclidean length  between $v_i$ and $a_j$ where $v_i \in H, a_j \in A$.

We want to find a tour $\varphi$ that starts and ends at the base station. A tour is said to be feasible if it has no repeated nodes (other than the base station as its first and last element), repairs all sensor holes (i.e., drops a passive sensor as the location of each damaged device), and never violates the robotâ€™s capacity constraint. This tour must consider the following objectives:

\begin{equation} \label {eq:length}
min\sum_{e_{ij} \in \varphi} d_{ij}
\end{equation}

\begin{equation} \label {eq:robustness}
max \sum_{v_i,v_j}\frac{p_i}{g_j}\delta(v_i,v_j), v_i \in \varphi \cap S, v_j \in \varphi \cap H
\end{equation}


\begin{equation} \label {eq:lifetime}
max(min (p_i)), v_i \in \varphi \cap S
\end{equation}

where \eqref{eq:length} represents the path length, \eqref{eq:robustness} is a metric we call the path robustness, and \eqref{eq:lifetime} represents the lifetime of the path. The function $\delta(v_i,v_j)$ is evaluated as follows:

\begin{equation} \label {eq:dropoff}
\delta(v_i,v_j) = \left\{ \begin{array}{ll}
1 & \quad \text{if $v_i$ will replace $v_j$} \\
0 & \quad \text{otherwise} \\
\end{array} \right.
\end{equation}

\textbf{ILP Formulation?} \\

\section{EMOO Algorithms for RRASR}
\label{sec:Algorithms}

In this Section we unveil several common building blocks of the EMOO algorithms that will be applied to solve the RRASR problem.

\subsection{Solution Encoding}
\label{sec:Algorithms:Encoding}

We use a modified version of a permutation-based representation used in \cite{liao2010evolutionary}. For a problem instance with n nodes we will use a permutation of $n-1$ integers (we will not include the depot node, $v_0$, in the permutation). Each permutation will take the form of $\left\{ 1,...,n \right\}$ to represent the visiting order of the nodes. Nodes that are not visited in the tour will be made negative such that only nodes represented by a positive integer will be visited in the tour.

\subsection{Objective Functions}
\label{sec:Algorithms:ObjFunctions}

We use a multi-objective optimization approach in which fitness functions \eqref{eq:length}, \eqref{eq:robustness}, and \eqref{eq:lifetime} are evaluated and have no precedence over each other. As a result the pareto-optimal set of solutions will be evaluated at each generation.

\subsection{Evolutionary Operators}
\label{sec:Algorithms:Operators}

\subsubsection{Selection Operator}
\label{sec:Algorithms:Operators:Selection}
We will use binary tournament selection in which two solutions are randomly chosen and the best solution from the pair will be selected. Since this is an MOO problem the rank of a given solution, rather than a single fitness function, will be used for comparison.

\subsubsection{Crossover Operator}
\label{sec:Algorithms:Operators:Crossover}
We used partially-mapped crossover \cite{goldberg1985alleles} as our crossover operator.


\subsubsection{Mutation Operator}
\label{sec:Algorithms:Operators:Mutation}
We use two mutation operators, swap and insert. Each gene has a probability of undergoing a mutation when it is selected. The element insertion mutation works by removing an item from the permutation and inserting it into a random new location in the permutation. The swap works by randomly selecting two indexes of the permutation and switching their values.

Due to the special nature of our permutation, these mutations have too little of an effect on the solution. As they are now, there is a high likelihood that a mutation will have no effect on the solution vector that results from a permutation. This happens due to the negative number representation in the permutation. If only negative numbers are affected by a mutation, the mutation will have no effect on the solution. In order to make the mutations more volatile, whenever an element of the permutation is affected by a mutation it also has its sign flipped. This guarantees a change in the solution vector of a permutation. This was found to have a better effect on the solution space than the default mutations as it encouraged more exploration by the genetic algorithm.

\subsection{Infeasibility Handling}
\label{sec:Algorithms:Infeasibility}

We look at the constraints of the problem and repair a given individual if it violates them. In the case $|\varphi| = 2|H|-Q_0$ or $H \subseteq \varphi$ is not satisfied we use the following methods to ensure that a solution will be viable.
\begin{itemize}
\item In the case $H \subseteq \varphi$ is not true, we add the remaining elements of $H$ to $\varphi$ . We do this by making all elements in $H$ in the encoded solution positive if they are not already.

\item If $|\varphi| > 2|H|-Q_0$, remove $v_i \in S$ from from right to left until $|\varphi| = 2|H|-Q_0$. We do this by iterating through the permutation from $n$ to $1$ making positive elements of $S$ negative until the condition is satisfied 

\item If  $|\varphi| < 2|H|-Q_0$, add $v_i \in S, v_i \notin \varphi$ from left to right until $|\varphi| = 2|H|-Q_0$. We do this by iterating through the permutation from $1$ to$n$ making negative elements of $S$ positive until the condition is satisfied.
\end{itemize}

The other constraint that must be considered for repair is: at all points in $\varphi$, $0 < Q < Q_{max}$ must hold. We must consider the two infeasible cases:
\begin{itemize}
\item If $Q > Q_{max}$ at some point in $\varphi$, move the offending $v_i \in \varphi \cup S$ after the nearest right $v_i \in \varphi \cup H$ in $\varphi$ . To do this we insert the vertex in which the issue appears after the rightmost element of $H$ that appears in the permutation.

\item If $Q < 0$ at some point in $\varphi$, move the offending $v_i \in \varphi \cup H$ after the nearest right $v_i \in \varphi \cup S$ in $\varphi$ . To do this we insert the vertex in which the issue appears after the rightmost element of $S$ that appears in the permutation.
\end{itemize}

This process must be done iteratively until the constraint is not violated in the solution.

\subsection{Population Initialization}
\label{sec:Algorithms:Initialization}
We initialize the population randomly plus three heuristically determined individuals, one for each of the objective functions. For path length we use a nearest neighbour approach keeping in mind the problem constraints. For path lifetime whenever there is a pickup it is always the sensor with the greatest battery that is selected, regardless of location. For path robustness we always pick the sensor with the greatest battery and deliver it to the sensing hole with the smallest degree regardless of location.

The randomly generated solutions are created by randomly adding the elements of the permutation one by one and making them positive or negative with a probability of 0.50. To prevent infeasible solutions from entering the population, all randomly generated solutions undergo the repair operation before entering the population.

\subsection{Stop Criteria}
\label{sec:Algorithms:StopCriteria}
The algorithms will terminate after a set number of objective function evaluations has occurred.


%NSGA-II will terminate after a maximum running time has elapsed. This is due to the time-critical nature of the response generation phase in our case study.

\section{Experimental Results}
\label{sec:Experiments}

This Section elaborates on the empirical evaluation of the proposed MOO methodology for the RRASR problem.

\subsection{Experimental Setup}
\label{sec:Experiments:Setup:Scenarios}

\subsubsection{Synthetic Scenario Generation}
\label{sec:Experiments:Scenarios}

The scenarios used for testing the problem implementation have been programmatically generated with the ability to control the parameters of the scenario being generated. The scenario generator is able to control the number of passive sensors, the ratio of sensing holes to passive sensors, and the density of the passive sensors. The density of passive sensors is controlled by the  MAX\_DPA algorithm adapted from \cite{onat2008generating}. In order to simulate a semi-realistic scenario, we first map a grid of active sensors, as per \cite{fletcher2010back}\cite{li2014placing}, that would represent the sensor network in the ROI. We then take a number of those active sensors and turn them into sensing holes to be replaced by our robot. That set of passive sensors and sensing holes then becomes the problem instance to be solved.

We generated 109 scenarios for the following parameters: 50 for varying numbers of nodes, from 10 to 1000. 49 for varying ratios of sensing holes to passive sensors, from 1 to 49 percent. Lastly 10 for the density of the passive sensors, from each having a communication degree of 1 to a communication degree of 10.

\subsubsection{Algorithm and Parameter Configurations}
\label{sec:Simulations:AlgorithmsAndParameters}
The algorithms being tested are NSGA-II\cite{Deb2002:NSGA-II}, SPEA2\cite{zitzler2001spea2}, NSGA-III\cite{6600851}, and IBEA\cite{zitzler2004indicator}. IBEA is a special case because it is an indicator based algorithm and therefore requires a reference set in order to function. As a result of this, we created a reference set for each instance file. These are approximate pareto optimal sets created by running the following algorithms 25 times and combining their resulting pareto sets: NSGA-II, SPEA2,  NSGA-III, and PAES\cite{knowles2000approximating}.

The default parameters, when not otherwise modified by the experiments, are as follows: 
\begin{table}[h]
\begin{tabular}{ll}
Number of Nodes &	200 \\
Density &  No Restriction \\
Percent of Sensing Holes & 15 \\
Population Size & 200 \\
Number of Generations &  500 \\
Probability of Crossover & 0.75 \\ 
Probability of Mutation & 0.25 \\
\end{tabular}
\end{table}

\subsubsection{Performance Metrics}
\label{sec:Experiments:Metrics}

\subsection{Experiment 1: Scalability Analysis}
\label{sec:Simulations:Experiment1}

\subsection{Experiment 2: Network Density Analysis}
\label{sec:Simulations:Experiment2}

\subsection{Experiment 3: Network Damage(?) Analysis}
\label{sec:Simulations:Experiment3}


\section{Conclusions}
\label{sec:Conclusions}


\bibliographystyle{ieeetr}
\bibliography{RRASR-CEC-References2}

\end{document}
